-- Link ACHIEVEMENT to CANDIDATE via candidate_id and remove election_name.
-- This script merges duplicate achievements for the same candidate and is safe to run.

BEGIN;

-- 1. Add candidate_id column to ACHIEVEMENT if missing
ALTER TABLE ACHIEVEMENT
  ADD COLUMN IF NOT EXISTS candidate_id INTEGER;

-- 2. Prepare helper temp table for matching and merging
CREATE TEMP TABLE __tmp_achievement_candidates AS
SELECT
  LOWER(candidate_name) AS candidate_name_lower,
  candidate_name,
  election_name,
  content
FROM ACHIEVEMENT;

-- 3. Populate candidate_id in ACHIEVEMENT using case-insensitive matching
UPDATE ACHIEVEMENT a
SET candidate_id = c.candidate_id
FROM CANDIDATE c
WHERE a.candidate_id IS NULL
  AND LOWER(c.name) = LOWER(a.candidate_name);

-- 4. Handle duplicates: multiple achievements for same candidate (different elections)
-- We need to merge them into one record per candidate to satisfy the upcoming unique constraint (candidate_id).
-- We'll keep the one with the latest ID (or arbitrary) and append content from others.

-- 4a. Identify duplicates (same candidate_id)
CREATE TEMP TABLE __tmp_duplicates AS
SELECT candidate_id
FROM ACHIEVEMENT
WHERE candidate_id IS NOT NULL
GROUP BY candidate_id
HAVING COUNT(*) > 1;

-- 4b. For each duplicate group, create a merged content string.
-- This is complex in pure SQL update. Strategy:
--   i. Create a new temporary table holding the merged content for these candidates.
--   ii. Update one 'primary' record for the candidate with merged content.
--   iii. Delete the other records.

CREATE TEMP TABLE __tmp_merged_content AS
SELECT
  candidate_id,
  STRING_AGG(
    CONCAT('<h3>', election_name, '</h3>', content),
    '<hr>' ORDER BY election_name DESC
  ) as merged_content
FROM ACHIEVEMENT
WHERE candidate_id IN (SELECT candidate_id FROM __tmp_duplicates)
GROUP BY candidate_id;

-- 4c. Update one record to become the survivor (e.g., min id)
UPDATE ACHIEVEMENT a
SET content = m.merged_content,
    election_name = 'MERGED' -- Temporary marker
FROM __tmp_merged_content m
WHERE a.candidate_id = m.candidate_id
  AND a.achievement_id = (
    SELECT MIN(sub.achievement_id)
    FROM ACHIEVEMENT sub
    WHERE sub.candidate_id = a.candidate_id
  );

-- 4d. Delete the other records for these candidates
DELETE FROM ACHIEVEMENT a
WHERE candidate_id IN (SELECT candidate_id FROM __tmp_duplicates)
  AND achievement_id != (
    SELECT MIN(sub.achievement_id)
    FROM ACHIEVEMENT sub
    WHERE sub.candidate_id = a.candidate_id
  );

-- 5. Enforce NOT NULL on candidate_id now that data is clean
-- Note: If there were achievements with no matching candidate, they are still NULL.
-- We might want to delete them or leave them?
-- DECISION: Delete orphaned achievements that couldn't be linked to a candidate.
DELETE FROM ACHIEVEMENT WHERE candidate_id IS NULL;

ALTER TABLE ACHIEVEMENT
  ALTER COLUMN candidate_id SET NOT NULL;

-- 6. Remove election_name column
ALTER TABLE ACHIEVEMENT
  DROP COLUMN IF EXISTS election_name;

-- 7. Update Unique Constraints
ALTER TABLE ACHIEVEMENT
  DROP CONSTRAINT IF EXISTS achievement_candidate_name_election_name_key;

-- Also drop autogenerated typeorm constraints if they exist (names vary, so we might need to be loose or specific)
-- best effort to drop common conventions or check system catalog if this was critical script,
-- but for now we proceed with standard constraints.

ALTER TABLE ACHIEVEMENT
  DROP CONSTRAINT IF EXISTS "UQ_achievement_candidate_id"; -- prevent collision if rerunning partially

ALTER TABLE ACHIEVEMENT
  ADD CONSTRAINT achievement_candidate_id_key UNIQUE (candidate_id);

-- 8. Add Foreign Key
ALTER TABLE ACHIEVEMENT
  DROP CONSTRAINT IF EXISTS achievement_candidate_id_fkey;

ALTER TABLE ACHIEVEMENT
  ADD CONSTRAINT achievement_candidate_id_fkey
    FOREIGN KEY (candidate_id) REFERENCES CANDIDATE(candidate_id)
    ON DELETE CASCADE;

-- 9. Cleanup temp tables
DROP TABLE IF EXISTS __tmp_achievement_candidates;
DROP TABLE IF EXISTS __tmp_duplicates;
DROP TABLE IF EXISTS __tmp_merged_content;

COMMIT;
